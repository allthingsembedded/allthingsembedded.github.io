<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ARM on AllThingsEmbedded</title><link>https://allthingsembedded.com/tags/arm/</link><description>Recent content in ARM on AllThingsEmbedded</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 25 Feb 2025 21:13:08 +0100</lastBuildDate><atom:link href="https://allthingsembedded.com/tags/arm/index.xml" rel="self" type="application/rss+xml"/><item><title>Linkers and orphaned sections</title><link>https://allthingsembedded.com/post/orphan_sections_linker/</link><pubDate>Tue, 25 Feb 2025 21:13:08 +0100</pubDate><guid>https://allthingsembedded.com/post/orphan_sections_linker/</guid><description>&lt;h2 id="problem-statement">Problem statement&lt;/h2>
&lt;p>I recently came across a situation in a project where I had the following code:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">FaultInfo&lt;/span> &lt;span class="k">final&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">r0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">r1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// And all the other register state of a Cortex-M0+ processor
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">crc&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">[[gnu::section(&amp;#34;.uninit&amp;#34;)]]&lt;/span> &lt;span class="k">volatile&lt;/span> &lt;span class="n">FaultInfo&lt;/span> &lt;span class="n">fault_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>I was using this static region of data to persist some fault information across
reboots, to log it on the next boot after recovering from the fault.&lt;/p></description></item><item><title>Bare Metal C++ Register Access API</title><link>https://allthingsembedded.com/post/bare-metal-register-access-api/</link><pubDate>Sat, 25 Sep 2021 20:26:21 +0200</pubDate><guid>https://allthingsembedded.com/post/bare-metal-register-access-api/</guid><description>&lt;h2 id="introduction-to-memory-mapping">Introduction to memory-mapping&lt;/h2>
&lt;p>&lt;strong>Note:&lt;/strong> This section is introductory material for those who are not yet familiar with the concept of memory-mapping. If you are already experienced with memory-mapping feel free to jump to the next section. Most likely you won&amp;rsquo;t miss anything new.&lt;/p>
&lt;p>One of the most common ways of accessing peripherals from a CPU is &lt;code>memory-mapping&lt;/code>. In short, this means that the address space of the CPU has some addresses that when accessed read/write peripheral&amp;rsquo;s registers. In order to access such peripherals from our code there are multiple strategies that could be used. This post will explore multiple alternatives and discuss their differences and fitness for their unique task.&lt;/p></description></item><item><title>Mastering the GNU linker script</title><link>https://allthingsembedded.com/post/2020-04-11-mastering-the-gnu-linker-script/</link><pubDate>Sat, 11 Apr 2020 21:25:34 +0000</pubDate><guid>https://allthingsembedded.com/post/2020-04-11-mastering-the-gnu-linker-script/</guid><description>&lt;p>Most people getting started with embedded development seem to find linker scripts just another piece of magic required to get up and running with their system. Even when they might already be familiar with memory-mapped peripherals and basic embedded concepts, the linker script and how it interacts with the GNU linker (ld) is still pretty mysterious.&lt;/p>
&lt;p>Today we will go through the main functions of a linker script to try to shed some light onto their operation. We covered the basic of cross compilation in a previous post. We mentioned that the linker would be the last step in the compilation process. The job of the linker is to take all input object files and libraries (both shared and static) and generate a single executable file. Let&amp;rsquo;s start with some terminology.&lt;/p></description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers: Booting the target application</title><link>https://allthingsembedded.com/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/</link><pubDate>Sat, 12 Oct 2019 18:23:57 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/</guid><description>&lt;p>In a previous &lt;a href="https://allthingsembedded.com/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/">blog&lt;/a> we discussed the role of the NVIC in ARM Cortex-M microcontrollers. This peripheral will play a central role in booting our target application. First of all, we need to discuss the boot process in an ARM Cortex-M microcontroller.&lt;/p>
&lt;h2 id="boot-process">Boot process&lt;/h2>
&lt;ul>
&lt;li>After Power On Reset the microcontroller assumes the NVIC table is located at address 0x00000000.&lt;/li>
&lt;li>The processor fetches the first two words in the NVIC table, corresponding to the &lt;strong>top of the stack&lt;/strong> and the &lt;strong>reset vector&lt;/strong>.&lt;/li>
&lt;li>It sets the MSP (Main stack pointer) to the top of the stack.&lt;/li>
&lt;li>It jumps to the address indicated by the reset vector.&lt;/li>
&lt;li>Application program execution begins.&lt;/li>
&lt;/ul>
&lt;p>In the case of our bootloader, the processor will be loading the top of the stack and the reset vector of our bootloader and then start executing it. Then, we the bootloader decides if it can boot an application already present at flash memory or if it needs to load an application using the loader. No matter which is chosen, it will eventually have to boot the target application.&lt;/p></description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers: Design</title><link>https://allthingsembedded.com/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</link><pubDate>Fri, 31 May 2019 15:37:18 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</guid><description>&lt;p>Welcome to the second entry of the &lt;a href="https://github.com/Javier-varez/stm32_bootloader">Bootloader&lt;/a> series! Today we are going to be discussing the design and basic architecture of the bootloader application.&lt;/p>
&lt;p>As we talked about on the last post, we are not going to be using any libraries, other than the C++ standard library in order to maximize portability and performance and limit code bloat. This means that we will be writing our own Hardware Abstraction Layer for all the peripherals and core features of the bootloader.&lt;/p></description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers (STM32F7): Introduction</title><link>https://allthingsembedded.com/post/2019-05-19-bootloaders-and-arm-cortex-m-microcontrollers-stm32f7-introduction/</link><pubDate>Sun, 19 May 2019 17:23:30 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-05-19-bootloaders-and-arm-cortex-m-microcontrollers-stm32f7-introduction/</guid><description>&lt;p>We are introducing a new series to the blog, containing all about bootloaders for small ARM Cortex-M microcontrollers. I hope you like it.&lt;/p>
&lt;h3 id="what-is-a-bootloader">What is a bootloader?&lt;/h3>
&lt;p>A bootloader is a piece of firmware that takes care of booting the target application, as well as providing a mechanism to update the firmware on the field, where you don&amp;rsquo;t have the means to flash the device using more advanced hardware interfaces such as JTAG, SWD or ICSP.&lt;/p></description></item><item><title>ARM Cortex-M Startup code (for C and C++)</title><link>https://allthingsembedded.com/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/</link><pubDate>Thu, 03 Jan 2019 09:00:50 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/</guid><description>&lt;p>When developing bare metal applications it is required to supply some functions that we normally take for granted when developing code for mainstream OS&amp;rsquo;s. Setting the startup code is not inherently difficult but beware: some of the nastiest bugs you will ever see on bare metal can come from the startup code.&lt;/p>
&lt;p>What is actually needed to start the execution of the main function? Well, there are a few things that the C and C++ language specifications assume when starting a new program. Some of them are:&lt;/p></description></item></channel></rss>