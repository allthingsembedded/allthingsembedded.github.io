<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>API on AllThingsEmbedded</title><link>https://allthingsembedded.com/tags/api/</link><description>Recent content in API on AllThingsEmbedded</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 02 Jan 2022 17:02:33 +0200</lastBuildDate><atom:link href="https://allthingsembedded.com/tags/api/index.xml" rel="self" type="application/rss+xml"/><item><title>Data Structures: Ditto::static_ptr&lt;Base, Derived, ...></title><link>https://allthingsembedded.com/post/data_structure_static_pointer/</link><pubDate>Sun, 02 Jan 2022 17:02:33 +0200</pubDate><guid>https://allthingsembedded.com/post/data_structure_static_pointer/</guid><description>&lt;p>One of the nice things about &lt;code>C++&lt;/code> compared to &lt;code>C&lt;/code> is its ability to define reusable types and data structures. They make code reuse easier and also help with reasoning if the abstraction is high-level enough.&lt;/p>
&lt;p>Today we are going to talk about &lt;code>static_ptr&lt;/code> from the library &lt;a href="https://github.com/javier-varez/ditto">Ditto&lt;/a>. Dynamic allocation is often forbidden when developing embedded systems. This leads to allocating most things either in the stack or globally. A &lt;code>static_ptr&lt;/code> allows the user to statically allocate an object of a derived class and access it as a base class pointer. The nice thing is that it allows to easily implement the &lt;code>factory pattern&lt;/code> if only one instance of each child is required at a time.&lt;/p></description></item><item><title>Bare Metal C++ Register Access API</title><link>https://allthingsembedded.com/post/bare-metal-register-access-api/</link><pubDate>Sat, 25 Sep 2021 20:26:21 +0200</pubDate><guid>https://allthingsembedded.com/post/bare-metal-register-access-api/</guid><description>&lt;h2 id="introduction-to-memory-mapping">Introduction to memory-mapping&lt;/h2>
&lt;p>&lt;strong>Note:&lt;/strong> This section is introductory material for those who are not yet familiar with the concept of memory-mapping. If you are already experienced with memory-mapping feel free to jump to the next section. Most likely you won&amp;rsquo;t miss anything new.&lt;/p>
&lt;p>One of the most common ways of accessing peripherals from a CPU is &lt;code>memory-mapping&lt;/code>. In short, this means that the address space of the CPU has some addresses that when accessed read/write peripheral&amp;rsquo;s registers. In order to access such peripherals from our code there are multiple strategies that could be used. This post will explore multiple alternatives and discuss their differences and fitness for their unique task.&lt;/p></description></item></channel></rss>