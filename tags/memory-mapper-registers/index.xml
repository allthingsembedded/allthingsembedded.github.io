<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memory-Mapper Registers on AllThingsEmbedded</title><link>https://allthingsembedded.com/tags/memory-mapper-registers/</link><description>Recent content in Memory-Mapper Registers on AllThingsEmbedded</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 25 Sep 2021 20:26:21 +0200</lastBuildDate><atom:link href="https://allthingsembedded.com/tags/memory-mapper-registers/index.xml" rel="self" type="application/rss+xml"/><item><title>Bare Metal C++ Register Access API</title><link>https://allthingsembedded.com/post/bare-metal-register-access-api/</link><pubDate>Sat, 25 Sep 2021 20:26:21 +0200</pubDate><guid>https://allthingsembedded.com/post/bare-metal-register-access-api/</guid><description>&lt;h2 id="introduction-to-memory-mapping">Introduction to memory-mapping&lt;/h2>
&lt;p>&lt;strong>Note:&lt;/strong> This section is introductory material for those who are not yet familiar with the concept of memory-mapping. If you are already experienced with memory-mapping feel free to jump to the next section. Most likely you won&amp;rsquo;t miss anything new.&lt;/p>
&lt;p>One of the most common ways of accessing peripherals from a CPU is &lt;code>memory-mapping&lt;/code>. In short, this means that the address space of the CPU has some addresses that when accessed read/write peripheral&amp;rsquo;s registers. In order to access such peripherals from our code there are multiple strategies that could be used. This post will explore multiple alternatives and discuss their differences and fitness for their unique task.&lt;/p></description></item></channel></rss>