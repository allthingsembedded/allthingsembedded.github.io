<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>AllThingsEmbedded</title><link>https://allthingsembedded.com/</link><description>Recent content on AllThingsEmbedded</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 25 Feb 2025 21:13:08 +0100</lastBuildDate><atom:link href="https://allthingsembedded.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Linkers and orphaned sections</title><link>https://allthingsembedded.com/post/orphan_sections_linker/</link><pubDate>Tue, 25 Feb 2025 21:13:08 +0100</pubDate><guid>https://allthingsembedded.com/post/orphan_sections_linker/</guid><description>&lt;h2 id="problem-statement">Problem statement&lt;/h2>
&lt;p>I recently came across a situation in a project where I had the following code:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">struct&lt;/span> &lt;span class="nc">FaultInfo&lt;/span> &lt;span class="k">final&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">r0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">r1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// And all the other register state of a Cortex-M0+ processor
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">uint32_t&lt;/span> &lt;span class="n">crc&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">};&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">[[gnu::section(&amp;#34;.uninit&amp;#34;)]]&lt;/span> &lt;span class="k">volatile&lt;/span> &lt;span class="n">FaultInfo&lt;/span> &lt;span class="n">fault_data&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>I was using this static region of data to persist some fault information across
reboots, to log it on the next boot after recovering from the fault.&lt;/p></description></item><item><title>Data Structures: Ditto::static_ptr&lt;Base, Derived, ...></title><link>https://allthingsembedded.com/post/data_structure_static_pointer/</link><pubDate>Sun, 02 Jan 2022 17:02:33 +0200</pubDate><guid>https://allthingsembedded.com/post/data_structure_static_pointer/</guid><description>&lt;p>One of the nice things about &lt;code>C++&lt;/code> compared to &lt;code>C&lt;/code> is its ability to define reusable types and data structures. They make code reuse easier and also help with reasoning if the abstraction is high-level enough.&lt;/p>
&lt;p>Today we are going to talk about &lt;code>static_ptr&lt;/code> from the library &lt;a href="https://github.com/javier-varez/ditto">Ditto&lt;/a>. Dynamic allocation is often forbidden when developing embedded systems. This leads to allocating most things either in the stack or globally. A &lt;code>static_ptr&lt;/code> allows the user to statically allocate an object of a derived class and access it as a base class pointer. The nice thing is that it allows to easily implement the &lt;code>factory pattern&lt;/code> if only one instance of each child is required at a time.&lt;/p></description></item><item><title>Bare Metal C++ Register Access API</title><link>https://allthingsembedded.com/post/bare-metal-register-access-api/</link><pubDate>Sat, 25 Sep 2021 20:26:21 +0200</pubDate><guid>https://allthingsembedded.com/post/bare-metal-register-access-api/</guid><description>&lt;h2 id="introduction-to-memory-mapping">Introduction to memory-mapping&lt;/h2>
&lt;p>&lt;strong>Note:&lt;/strong> This section is introductory material for those who are not yet familiar with the concept of memory-mapping. If you are already experienced with memory-mapping feel free to jump to the next section. Most likely you won&amp;rsquo;t miss anything new.&lt;/p>
&lt;p>One of the most common ways of accessing peripherals from a CPU is &lt;code>memory-mapping&lt;/code>. In short, this means that the address space of the CPU has some addresses that when accessed read/write peripheral&amp;rsquo;s registers. In order to access such peripherals from our code there are multiple strategies that could be used. This post will explore multiple alternatives and discuss their differences and fitness for their unique task.&lt;/p></description></item><item><title>Mastering the GNU linker script</title><link>https://allthingsembedded.com/post/2020-04-11-mastering-the-gnu-linker-script/</link><pubDate>Sat, 11 Apr 2020 21:25:34 +0000</pubDate><guid>https://allthingsembedded.com/post/2020-04-11-mastering-the-gnu-linker-script/</guid><description>&lt;p>Most people getting started with embedded development seem to find linker scripts just another piece of magic required to get up and running with their system. Even when they might already be familiar with memory-mapped peripherals and basic embedded concepts, the linker script and how it interacts with the GNU linker (ld) is still pretty mysterious.&lt;/p>
&lt;p>Today we will go through the main functions of a linker script to try to shed some light onto their operation. We covered the basic of cross compilation in a previous post. We mentioned that the linker would be the last step in the compilation process. The job of the linker is to take all input object files and libraries (both shared and static) and generate a single executable file. Let&amp;rsquo;s start with some terminology.&lt;/p></description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers: Booting the target application</title><link>https://allthingsembedded.com/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/</link><pubDate>Sat, 12 Oct 2019 18:23:57 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-10-12-bootloaders-and-arm-cortex-m-microcontrollers-booting-the-target-application/</guid><description>&lt;p>In a previous &lt;a href="https://allthingsembedded.com/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/">blog&lt;/a> we discussed the role of the NVIC in ARM Cortex-M microcontrollers. This peripheral will play a central role in booting our target application. First of all, we need to discuss the boot process in an ARM Cortex-M microcontroller.&lt;/p>
&lt;h2 id="boot-process">Boot process&lt;/h2>
&lt;ul>
&lt;li>After Power On Reset the microcontroller assumes the NVIC table is located at address 0x00000000.&lt;/li>
&lt;li>The processor fetches the first two words in the NVIC table, corresponding to the &lt;strong>top of the stack&lt;/strong> and the &lt;strong>reset vector&lt;/strong>.&lt;/li>
&lt;li>It sets the MSP (Main stack pointer) to the top of the stack.&lt;/li>
&lt;li>It jumps to the address indicated by the reset vector.&lt;/li>
&lt;li>Application program execution begins.&lt;/li>
&lt;/ul>
&lt;p>In the case of our bootloader, the processor will be loading the top of the stack and the reset vector of our bootloader and then start executing it. Then, we the bootloader decides if it can boot an application already present at flash memory or if it needs to load an application using the loader. No matter which is chosen, it will eventually have to boot the target application.&lt;/p></description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers: Design</title><link>https://allthingsembedded.com/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</link><pubDate>Fri, 31 May 2019 15:37:18 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-05-31-bootloaders-and-arm-cortex-m-microcontrollers-design/</guid><description>&lt;p>Welcome to the second entry of the &lt;a href="https://github.com/Javier-varez/stm32_bootloader">Bootloader&lt;/a> series! Today we are going to be discussing the design and basic architecture of the bootloader application.&lt;/p>
&lt;p>As we talked about on the last post, we are not going to be using any libraries, other than the C++ standard library in order to maximize portability and performance and limit code bloat. This means that we will be writing our own Hardware Abstraction Layer for all the peripherals and core features of the bootloader.&lt;/p></description></item><item><title>Bootloaders and ARM Cortex-M microcontrollers (STM32F7): Introduction</title><link>https://allthingsembedded.com/post/2019-05-19-bootloaders-and-arm-cortex-m-microcontrollers-stm32f7-introduction/</link><pubDate>Sun, 19 May 2019 17:23:30 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-05-19-bootloaders-and-arm-cortex-m-microcontrollers-stm32f7-introduction/</guid><description>&lt;p>We are introducing a new series to the blog, containing all about bootloaders for small ARM Cortex-M microcontrollers. I hope you like it.&lt;/p>
&lt;h3 id="what-is-a-bootloader">What is a bootloader?&lt;/h3>
&lt;p>A bootloader is a piece of firmware that takes care of booting the target application, as well as providing a mechanism to update the firmware on the field, where you don&amp;rsquo;t have the means to flash the device using more advanced hardware interfaces such as JTAG, SWD or ICSP.&lt;/p></description></item><item><title>Getting SpiritDSP MP3 Decoder up and running on STM32 Microcontrollers</title><link>https://allthingsembedded.com/post/2019-02-17-getting-spiritdsp-mp3-decoder-up-and-running-on-stm32-microcontrollers/</link><pubDate>Sun, 17 Feb 2019 14:44:58 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-02-17-getting-spiritdsp-mp3-decoder-up-and-running-on-stm32-microcontrollers/</guid><description>&lt;p>After researching some alternatives for mp3 decoding on STM32 microcontrollers, I found ST&amp;rsquo;s X-CUBE-AUDIO, a set of libraries and components for audio processing. It turns out that SpiritDSP developed a version of their MP3 decoding libraries for STM microcontrollers.&lt;/p>
&lt;p>You can download the software expansion kit following &lt;a href="https://www.st.com/en/embedded-software/x-cube-audio.html">this&lt;/a> link. It contains much more than just the SpiritDSP MP3 decoder, but this article will be focused just on how to get the MP3 decoder up and running.&lt;/p></description></item><item><title>ARM Cortex-M Startup code (for C and C++)</title><link>https://allthingsembedded.com/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/</link><pubDate>Thu, 03 Jan 2019 09:00:50 +0000</pubDate><guid>https://allthingsembedded.com/post/2019-01-03-arm-cortex-m-startup-code-for-c-and-c/</guid><description>&lt;p>When developing bare metal applications it is required to supply some functions that we normally take for granted when developing code for mainstream OS&amp;rsquo;s. Setting the startup code is not inherently difficult but beware: some of the nastiest bugs you will ever see on bare metal can come from the startup code.&lt;/p>
&lt;p>What is actually needed to start the execution of the main function? Well, there are a few things that the C and C++ language specifications assume when starting a new program. Some of them are:&lt;/p></description></item><item><title>Cross-compiling for embedded devices</title><link>https://allthingsembedded.com/2018/12/29/cross-compiling-for-embedded-devices/</link><pubDate>Sat, 29 Dec 2018 17:36:13 +0000</pubDate><guid>https://allthingsembedded.com/2018/12/29/cross-compiling-for-embedded-devices/</guid><description>&lt;p>Developing code for embedded devices is somewhat different from code for mainstream computers. One of these differences is the development environment.&lt;/p>
&lt;p>Most of the target microcontrollers or microprocessors won&amp;rsquo;t usually be suited for local development. Imagine trying to build your code on the target when the target is a simple 8-bit Microcontroller. First of all you would need a compiler for the target architecture on the target device and it would probably be extra slow and inconvenient. That is the reason behind cross-compilers (provided that the uC has enough power and memory to perform the compilation process).&lt;/p></description></item><item><title>Adding GPT support to FatFS</title><link>https://allthingsembedded.com/2018/12/29/adding-gpt-support-to-fatfs/</link><pubDate>Sat, 29 Dec 2018 11:27:30 +0000</pubDate><guid>https://allthingsembedded.com/2018/12/29/adding-gpt-support-to-fatfs/</guid><description>&lt;p>&lt;a href="http://elm-chan.org/fsw/ff/00index_e.html">FatFs&lt;/a> is an open source library used in many embedded devices to interface with FAT file systems in Block devices such as SD cards, flash drives, etc. It can load a FAT or ExFAT filesystem found inside a partition in an MBR partition table. However, it doesn&amp;rsquo;t provide support to find a FAT filesystem inside a GUID partition table.&lt;/p>
&lt;p>This blog post will provide you with the knowledge required to load a FAT filesystem inside a GUID partition table using FatFS. For this purpose, I have chosen revision R0.10b, mainly because it is the currently supported version for Xilinx SDK Board Support Package for Zynq devices.&lt;/p></description></item><item><title>Displaying text on embedded devices</title><link>https://allthingsembedded.com/2018/09/02/displaying-text-on-embedded-devices/</link><pubDate>Sun, 02 Sep 2018 04:00:37 +0000</pubDate><guid>https://allthingsembedded.com/2018/09/02/displaying-text-on-embedded-devices/</guid><description>&lt;p>There are many ways to display text on an embedded device, but not all of them may fit your HW design. This post will expose most of your options and give you a good intuition about what you need to know in order to create great graphics software. Even if you only do hardware, this will still be of interest to you, since you will get a better understanding of what the architecture of your system needs to be to be able to display text with a certain quality.&lt;/p></description></item><item><title>On controlling GPIO speed</title><link>https://allthingsembedded.com/2018/06/23/on-controlling-gpio-speed/</link><pubDate>Sat, 23 Jun 2018 23:07:17 +0000</pubDate><guid>https://allthingsembedded.com/2018/06/23/on-controlling-gpio-speed/</guid><description>&lt;p>Most microcontrollers now include the options to select the GPIO speed for a certain pin inside a port. Many will announce this feature as GPIO max current control or slew-rate, but in the end they are talking about the same thing.&lt;/p>
&lt;p>First of all, why would you ever need to control GPIO current? Wouldn&amp;rsquo;t it be great to leave this at the maximum level at all times? Well, it is usually not that simple, and more so as integrated circuits get larger clock frequencies. Let&amp;rsquo;s consider the following model of a push-pull GPIO in an STM32 microcontroller:&lt;/p></description></item></channel></rss>